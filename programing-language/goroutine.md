---
title: "Goroutine"
date: 2020-07-01T10:05:02+08:00
description: ""
draft: false
tags: []
categories: [Golang]
---

# 进程·线程·协程

概念上来说，进程和线程都是内核来进行调度的，有CPU时间片的概念，进行的是抢占式调度。协程是工作在用户空间的，是用户级线程，也就是说，协程对于内核是透明的，内核感知不到协程的存在，完全由用户程序自行控制，这样就不能像内核的进程和线程那样进行抢占式调度，只能自己协调式调度，协程主动把控制权交出去，其他协程才能执行。

进程是资源分配和调度的基本单位，线程是CPU调度的基本单位。可以这样理解，计算机资源抽象分为计算资源和存储资源，进程可以申请存储和CPU。也就是进程可以分配运行的全部资源。线程其实是进程的一个实体，线程不能独立分配存储资源，也就是说，一个进程的多个线程是共享存储空间的。但是线程可以分配计算资源，也就是说可以参与CPU的调度。线程只拥有运行的必不可少的资源，不分配系统资源。

一个程序至少拥有一个进程，一个进程至少拥有一个线程。

多线程适用CPU密集型，用于多分配CPU来计算

多线程适用于IO密集型，用于服务端响应客户端，适用于大量IO操作

# 协程

本质上来说，goroutine就是协程，区别在于，Golang在runtime和系统调用多方面对goroutine进行了封装和处理，等待时间长时，会主动让出CPU。

1，内存消耗：2K， 线程：8M

2，线程切换，涉及16个寄存器，goroutine：涉及3个寄存器

#### GO协程的实现原理

多线程编程时，上下文的切换存在一定的消耗。协程是在应用层模拟的线程，避免了上下文切换的消耗，兼顾了多线程的优点。如：一个socket连接可以用一个协程来处理。

线程和协程的实现原理是一样的。线程切换时，需要把上一个执行的线程压栈，当前运行的线程信息出栈，协程是在应用层实现了这一点，但协程不是操作系统调度的，是应用程序调度的。但一般会问？应用程序没有cpu调度的能力啊，怎么解决呢？

其实，协程是基于线程的。在内部实现来说，维护了一组数据结构和一组线程，真正来执行的还是线程。协程执行的代码被存储在一个队列中，待执行队列，维护的一组线程不断的拉取协程来执行。协程是怎么切换的呢？golang本身封装了系统的io函数，通过runtime统一提供给程序适用，内部调用了系统的异步io函数，当函数返回busy或者阻塞状态时，golang本身会存储状态，然后通知调度器继续执行其他协程。

Goroutine采用的是M：N模型实现的用户态协程调度机制，也就是m个协程运行在n个系统线程上。一个goroutine执行系统调用时，系统线程会阻塞，这时候调度器会唤醒一个新的线程或者创建一个新的线程来继续执行协程。当发生管道调用时，进程可能会阻塞，但是系统线程和协程不会阻塞，会继续执行。

Go调度模型

M P G Sched

![groutine](http://cdn.oyfacc.cn/groutine.png)

M代表用户线程，M是一个大结构，里面有当前执行的协程等信息，P是处理器，用于运行协程，还有一个队列，存储了要执行的协程，G是协程

sched是调度器，维护M和G队列等一些状态信息。

P的数量一般取决于GoMAXPROCS环境变量，通常和核心数相等，最大限度利用CPU。

G的数量一般会有很多，每个P都会从G的就绪队列pop操作，一般一个P负责一个队列，减少锁的开销。

当groutine需要执行一个系统调用时，由于M是一个线程，所以必须等待完成，此时，必须保证有一个M能正常执行其他G。当系统调用返回时，M需要调度G到一个P上，继续执行，如果不能，需要把G放到全局队列中，并且自己放到线程缓存中。

P其实是一个衔接M和G的调度上下文，负责他们直接的对接。

#### 调度器

![runtime](http://cdn.oyfacc.cn/go-runtime.png)

上图可以清晰的看到，go程序运行时统一经过runtime来和底层交互

![gpm](http://cdn.oyfacc.cn/gogpm.png)

go运行时有两个队列，全局队列和本地队列，本地队列就是自己维护的队列，为了运行G，M需要持有上下文P，M从P的队列弹出G来执行。新创建的G被放在P的队列中，当M执行的P的队列为空的时候，会随机选择一个P，把他队列中的G取走一般到自己的P的队列中，也就是窃取。

当G阻塞，M也会阻塞，runtime会把M从P上摘除，创建新的M，如果没有空闲的M的话，然后把P和M连接，继续运行。